#
# Nimble package signing
#
# Copyright 2016 Federico Ceratto <federico.ceratto@gmail.com>
# Released under GPLv3 License, see LICENSE file
#

import base64
import json
import os
import osproc
import streams
import strutils
from tables import keys, pairs
import tables
import tempfile
from sequtils import toSeq
from algorithm import sorted

const gpg_path = "/usr/bin/gpg"


proc to_s_ugly(result: var string, node: JsonNode) =
  ## Converts `node` to its JSON Representation, without
  ## regard for human readability. Meant to improve ``$`` string
  ## conversion performance.
  ##
  ## JSON representation is stored in the passed `result`
  ##
  ## This provides higher efficiency than the ``pretty`` procedure as it
  ## does **not** attempt to format the resulting JSON to make it human readable.
  var comma = false
  case node.kind:
  of JArray:
    result.add "["
    for child in node.elems:
      if comma: result.add ","
      else:     comma = true
      result.to_s_ugly child
    result.add "]"
  of JObject:
    result.add "{"
    for n, key_value in toSeq(pairs(node.fields)).sorted(system.cmp):
      let (key, value) = key_value
      if comma: result.add ","
      else:     comma = true
      result.add key.escapeJson()
      result.add ":"
      result.to_s_ugly value
    result.add "}"
  of JString:
    result.add node.str.escapeJson()
  of JInt:
    result.add($node.num)
  of JFloat:
    result.add($node.fnum)
  of JBool:
    result.add(if node.bval: "true" else: "false")
  of JNull:
    result.add "null"

proc serialize(node: JsonNode): string =
  ## Serialize node
  ## Keys are sorted lexicographically, the indentation is two whitespaces,
  ## there are no newlines and spaces at the beginning and the end.

  result = newStringOfCap(node.len shl 1)
  to_s_ugly(result, node)

proc generate_gpg_signature*(node: JsonNode, key: string): string =
  ## Generate GPG signature for a JSON node
  ## The signature is generated by GPG-signing the output of
  ## pretty(indent=2)
  ## Keys are sorted lexicographically, the indentation is two whitespaces,
  ## there are no newlines and spaces at the beginning and the end.
  let
    tmp_dir = mkdtemp()
    tmp_clearfn = tmp_dir / "cleartext"
    tmp_signature = tmp_dir / "signature"

  tmp_clearfn.writeFile(node.serialize)
  let cmd = "$# --detach-sign --output $# $#" % [gpg_path, tmp_signature, tmp_clearfn]
  let cmd_out = execProcess(cmd)
  # FIXME check output
  result = tmp_signature.readFile().encode()
  tmp_dir.removeDir()

proc verify_gpg_signature*(node: JsonNode, signature: string): string =
  ## Verify a GPG signature
  let
    tmp_dir = mkdtemp()
    tmp_clearfn = tmp_dir / "cleartext"
    tmp_signature = tmp_dir / "signature"

  tmp_clearfn.writeFile(node.serialize)
  tmp_signature.writeFile(signature.decode())
  let gpg = startProcess(gpg_path, args = ["--verify", tmp_signature, tmp_clearfn])
  let exit_code = gpg.waitForExit(timeout=30)
  result = gpg.outputStream.readAll()
  tmp_dir.removeDir()
  if exit_code != 0:
    raise newException(Exception, "Bad signature:\n$#" % result)


proc verify_gpg_signature_is_allowed*(node: JsonNode, signature: string,
    accepted_keys: seq[string] = @[]): string =
  ## Verify that a GPG signature is valid and the key belongs to the set
  ## of accepted keys
  let gpg_out = verify_gpg_signature(node, signature)

  var signing_key = ""
  for line in gpg_out.splitLines:
    if line.contains("using ") and line.contains(" key 0x"):
      let p = line.find(" key 0x") + 5
      signing_key = line[p..p+18].toUpper

  for accepted_k in accepted_keys:
    if signing_key == accepted_k.toUpper:
      return signing_key

  raise newException(Exception, "$# is not an accepted key" % signing_key)
